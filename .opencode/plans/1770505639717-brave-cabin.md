# Dashboard Query Perf Refactor Plan

## 0) Mandatory setup (new session start)

- Load skills, exact order:
  1. `vercel-react-best-practices` (covers requested `react-best-practices` + `next-best-practices`)
  2. `convex-best-practices`
  3. `convex-realtime`
  4. `convex-schema-validator` (requested `convex-schema`)
  5. `convex-functions`
- Re-run 3 explore subagents (same split): frontend dashboard pages, Convex dashboard queries, schema/index/realtime.
- Keep scope: `apps/web/src/app/dashboard/**` + `apps/web/src/components/dashboard/**` + `packages/backend/convex/**`.

## 1) Audit findings (concrete bottlenecks)

- Monolith query in layout: `apps/web/src/app/dashboard/layout.tsx:52` calls `api.dashboard.getDashboard` once for all pages.
- Global large context payload: `apps/web/src/components/dashboard/dashboard-context.tsx:5-57` stores all KPIs/charts/tables, causes broad rerenders.
- Monolith backend payload: `packages/backend/convex/dashboard.ts:90-114` returns everything.
- Heavy collect + JS filtering: `packages/backend/convex/dashboard.ts:117-134`, `304-349`, `404`.
- Fallback full-table scan: `packages/backend/convex/dashboard.ts:395-401`.
- N+1 student lookups: `packages/backend/convex/dashboard.ts:410-417`.
- Fake pagination (`slice(0,20)`): `packages/backend/convex/dashboard.ts:209`, `221`.
- Client-side sort/slice: `apps/web/src/app/dashboard/page.tsx:73-87`.
- Unpaginated companion messages/threads: `packages/backend/convex/messages.ts:10-15`, `packages/backend/convex/threads.ts:8-13`.

## 2) Design rules (from skills + Context7 docs)

- Convex: avoid unbounded `collect`; use `withIndex` + `paginate` (`paginationOptsValidator`) for lists.
- Convex: index field order strict (eq on leading fields, range on next), design indexes per query shape.
- Realtime: split one huge subscription into page/widget subscriptions.
- React/Next: shrink `'use client' data surface; keep shared context tiny; fetch page-specific data in page components.

## 3) Target architecture

- Replace 1 monolith with small query modules (flat files; clear generated API names):
  - `packages/backend/convex/dashboardShared.ts` (validators/helpers)
  - `packages/backend/convex/dashboardFilters.ts`
  - `packages/backend/convex/dashboardOverview.ts`
  - `packages/backend/convex/dashboardRevenue.ts`
  - `packages/backend/convex/dashboardCustomers.ts`
  - `packages/backend/convex/dashboardQuality.ts`
  - `packages/backend/convex/dashboardOperations.ts`
- Keep `packages/backend/convex/dashboard.ts` temporarily as compatibility wrapper (`getDashboard`), then delete after parity checks.

## 4) Backend implementation (file-by-file)

### 4.1 Shared args + helpers

- Create `packages/backend/convex/dashboardShared.ts`.
- Move/normalize from `packages/backend/convex/dashboard.ts:5-33,272-349`:
  - `dateRangeValidator`, `dashboardFilterValidator`
  - `resolveRange`, `parseSubmittedAt`, `getSubmittedAtMs`
  - `matchesEssayFilters` (only cheap post-filter fallback)
  - utility aggregators (`sum`, `average`, `percent`, `groupCount`, `groupSum`, `seriesByDay`)

Example skeleton:

```ts
import { v } from "convex/values";

export const dashboardFilterValidator = v.object({
  dateRange: v.object({
    preset: v.union(
      v.literal("7d"),
      v.literal("30d"),
      v.literal("90d"),
      v.literal("ytd"),
      v.literal("custom"),
    ),
    from: v.optional(v.string()),
    to: v.optional(v.string()),
  }),
  turnaround: v.optional(v.string()),
  status: v.optional(v.string()),
  acquisition: v.optional(v.string()),
  draft: v.optional(v.union(v.string(), v.number())),
  customerType: v.optional(v.string()),
});
```

### 4.2 Query split

- `dashboardFilters.ts` -> `getFilterOptions` (small payload for header selects).
- `dashboardOverview.ts` -> `getOverview` (overview-only KPIs + mini datasets).
- `dashboardRevenue.ts` -> `getRevenue`.
- `dashboardCustomers.ts` -> `getCustomers`.
- `dashboardQuality.ts` -> `getQuality`.
- `dashboardOperations.ts` ->
  - `getOperationsSummary`
  - `listUnassignedEssays`
  - `listLateDeliveries`

Pagination contract (must follow Convex docs):

```ts
import {
  paginationOptsValidator,
  paginationResultValidator,
} from "convex/server";

export const listUnassignedEssays = query({
  args: {
    ...dashboardFilterValidator.fields,
    paginationOpts: paginationOptsValidator,
  },
  returns: paginationResultValidator(
    v.object({
      item_id: v.string(),
      student_id: v.string(),
      word_count: v.number(),
      turnaround: v.string(),
      revenue: v.number(),
    }),
  ),
  handler: async (ctx, args) => {
    return await ctx.db
      .query("essays")
      .withIndex("by_status_and_submitted_at", (q) =>
        q
          .eq("item_status", "Unassigned")
          .gte("submittedAtMs", fromMs)
          .lte("submittedAtMs", toMs),
      )
      .order("desc")
      .paginate(args.paginationOpts);
  },
});
```

### 4.3 Index/schema upgrades

- Edit `packages/backend/convex/schema.ts` (`essays` table) add optional denorm fields:
  - `draft_bucket: v.optional(v.string())` // `"1"|"2"|"3"|"4"|"5+"`
  - `student_acquisition_channel: v.optional(v.string())`
  - `student_is_multi_draft: v.optional(v.boolean())`
  - `student_location: v.optional(v.string())`
  - `is_late: v.optional(v.boolean())`
- Add indexes:
  - `by_status_turnaround_and_submitted_at` -> `["item_status", "turnaround", "submittedAtMs"]`
  - `by_draft_bucket_and_submitted_at` -> `["draft_bucket", "submittedAtMs"]`
  - `by_student_channel_and_submitted_at` -> `["student_acquisition_channel", "submittedAtMs"]`
  - `by_student_type_and_submitted_at` -> `["student_is_multi_draft", "submittedAtMs"]`
  - `by_is_late_and_submitted_at` -> `["is_late", "submittedAtMs"]`

Rationale: current filters (`turnaround/status/draft/acquisition/customerType`) are not fully index-addressable in `packages/backend/convex/dashboard.ts:357-387`.

### 4.4 Backfill/migration

- Edit `packages/backend/convex/migrations.ts`; add internal mutation:
  - `backfillEssayDashboardDimensions({ cursor? })`
  - paginate essays in batches (reuse existing pattern at `migrations.ts:11-34`)
  - compute + patch `draft_bucket`, `is_late`, student denorm fields.
  - schedule next batch via `ctx.scheduler.runAfter` until done.

### 4.5 Compatibility bridge

- Edit `packages/backend/convex/dashboard.ts`:
  - mark `getDashboard` deprecated
  - rewire internals to new helper/query logic (remove full `collect` fallback path)
  - keep until frontend cutover + parity done, then delete file in cleanup step.

## 5) Frontend implementation (file-by-file)

### 5.1 Centralize query args

- Add `apps/web/src/components/dashboard/use-dashboard-query-args.ts`.
- Move mapping logic from `apps/web/src/app/dashboard/layout.tsx:27-50` into hook.

### 5.2 Shrink layout responsibility

- Edit `apps/web/src/app/dashboard/layout.tsx`:
  - remove `useQuery(api.dashboard.getDashboard, queryArgs)` (`layout.tsx:52`)
  - remove `stableData` logic (`layout.tsx:55-62`)
  - load only `api.dashboardFilters.getFilterOptions`
  - pass only `filters` + `queryArgs` through context

Target pattern:

```tsx
const { filters, setFilters, queryArgs } = useDashboardQueryArgs()
const options = useQuery(api.dashboardFilters.getFilterOptions, { dateRange: queryArgs.dateRange })

<DashboardProvider value={{ filters, queryArgs }}>
  <DashboardHeader filters={filters} options={options.data ?? fallback} ... />
  {children}
</DashboardProvider>
```

### 5.3 Simplify dashboard context

- Edit `apps/web/src/components/dashboard/dashboard-context.tsx`:
  - delete `DashboardData` giant type (`dashboard-context.tsx:5-52`)
  - new value: `{ filters, queryArgs }`

### 5.4 Page-level queries

- `apps/web/src/app/dashboard/page.tsx` -> `useQuery(api.dashboardOverview.getOverview, queryArgs)`.
- `apps/web/src/app/dashboard/revenue/page.tsx` -> `useQuery(api.dashboardRevenue.getRevenue, queryArgs)`.
- `apps/web/src/app/dashboard/customers/page.tsx` -> `useQuery(api.dashboardCustomers.getCustomers, queryArgs)`.
- `apps/web/src/app/dashboard/quality/page.tsx` -> `useQuery(api.dashboardQuality.getQuality, queryArgs)`.
- `apps/web/src/app/dashboard/operations/page.tsx`:
  - `useQuery(api.dashboardOperations.getOperationsSummary, queryArgs)`
  - `usePaginatedQuery(api.dashboardOperations.listUnassignedEssays, queryArgs, { initialNumItems: 20 })`
  - `usePaginatedQuery(api.dashboardOperations.listLateDeliveries, queryArgs, { initialNumItems: 20 })`

Replace client-side slice/sort from `apps/web/src/app/dashboard/page.tsx:73-87` with server-returned preview arrays.

### 5.5 Companion pagination

- Edit `packages/backend/convex/messages.ts`: add `listByThreadPaginated` (`paginationOptsValidator` + `.paginate`).
- Edit `packages/backend/convex/threads.ts`: add paginated `listPaginated`.
- Edit `apps/web/src/components/dashboard/companion-chat.tsx:109-128`: switch to `usePaginatedQuery` for message history.

## 6) API contract (final)

- `api.dashboardFilters.getFilterOptions(args: DashboardFilters)` -> `{ turnaroundOptions; statusOptions; acquisitionOptions }`
- `api.dashboardOverview.getOverview(args)` -> overview KPIs + series + topChannel + preview rows
- `api.dashboardRevenue.getRevenue(args)` -> revenue KPIs + revenue/volume series + channel/turnaround breakdown
- `api.dashboardCustomers.getCustomers(args)` -> customer KPIs + location/channel performance
- `api.dashboardQuality.getQuality(args)` -> rating KPIs + byDraft + satisfaction
- `api.dashboardOperations.getOperationsSummary(args)` -> ops KPIs + byStatus
- `api.dashboardOperations.listUnassignedEssays(args + paginationOpts)` -> paginated table
- `api.dashboardOperations.listLateDeliveries(args + paginationOpts)` -> paginated table
- `api.messages.listByThreadPaginated({ threadId, paginationOpts })` -> paginated messages

## 7) Rollout order (safe)

1. Add schema fields/indexes + migrations.
2. Add new query modules + keep old `getDashboard` alive.
3. Move frontend page-by-page to new APIs.
4. Add temporary parity checker (dev-only): compare old/new key KPIs for same filters.
5. Remove deprecated monolith + old context data shape.

## 8) Verification (required)

- Codegen/type:
  - `bun run dev:server` (Convex schema + generated API)
  - `bun run check-types`
- App run:
  - `bun run dev:web`
- Manual route checks (all filters):
  - `/dashboard`
  - `/dashboard/revenue`
  - `/dashboard/customers`
  - `/dashboard/quality`
  - `/dashboard/operations`
  - `/dashboard/companion`
- Perf checks:
  - confirm no call to `api.dashboard.getDashboard` from layout
  - confirm operations + companion use cursor pagination (`CanLoadMore/Exhausted` states)
  - confirm no client `slice/sort` for preview tables

## 9) Risks + guardrails

- Risk: denorm fields stale if essays ingest path not patched -> guardrail: run scheduled backfill nightly until ingest hook updated.
- Risk: index mismatch -> guardrail: add indexes exactly in query order; rely on Convex type guidance in `withIndex` callback.
- Risk: UI regressions from context shape change -> guardrail: migrate per page, keep wrapper compatibility during transition.
